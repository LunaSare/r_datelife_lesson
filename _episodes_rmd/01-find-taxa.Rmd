---
source: Rmd
title: "1. Finding your taxa in the Open Tree of Life Taxonomy"
teaching: 5
exercises: 5
questions:
- "What is the Open Tree of Life Taxonomy?"
- "What are OTT ids?"
- 'What does TNRS stand for?'
objectives:
- "Getting OTT ids for some taxa."
- "Understanding TNRS and approximate matching."
# - "Finding the utility of taxonomic contexts"
# - "Discovering functions to handle a 'match_names' object."
keypoints:
- "Open Tree of Life Taxonomy ids, or OTT ids are unique numeric identifiers for individual taxa that the Open Tree of Life project uses to handle taxonomy."
# - "taxonomic context is very important to find the correct OTT ids for our taxa."
- "You can go from a scientific name to an OTT id using TNRS matching."
- "You can not go from a common name to OTT id using the Open Tree of Life tools."
---
```{r, eval = TRUE, echo = FALSE}
source("../bin/chunk-options.R")
```
<br/>
<br/>

<!-- ### The Open Tree Taxonomy and its identifiers -->

The [Open Tree of Life Taxonomy](https://tree.opentreeoflife.org/about/taxonomy-version/ott3.2) (**OTT** from now on) synthesizes taxonomic information from different sources and assigns each taxon a unique numeric identifier, which we refer to as the **OTT id**. To interact with the OTT (and any other Open Tree of Life services) using R, we will learn how to use the functions from the `rotl` package. If you don't know if you have the package installed, go to [setup](../setup.html) and follow the instructions there.

To deal with synonyms and scientific name misspellings, the Open Tree Taxonomy uses
the [Taxonomic Name Resolution Service](http://tnrs.iplantcollaborative.org/) (**TNRS**
from now on), that allows linking scientific names to a unique OTT id, while dealing
with misspellings, synonyms and scientific name variants. The functions from `rotl` that interact
with OTT's TNRS start with "tnrs_".

<br/>

### Getting OTT ids for a taxon

To get OTT ids for a taxon or set of taxa we will use the function `tnrs_match_names()`.
This function takes a character vector of one or more scientific names as main argument.

> ## Hands on! Running TNRS
>
> Do a `tnrs_match_names()` run for the amphibians (Amphibia). Save the output to an object named `resolved_name`.
>
> You can try different misspellings and synonyms of your taxon to see TNRS in action.
>
>
> ```{r, eval = TRUE}
>
> resolved_name <- rotl::tnrs_match_names(names = "amphibians")
> ```
>
>
{: .challenge}

<br/>


### The 'match_names' object

Ok, we were able to run the function `tnrs_match_names` successfully. Now, let's explore its output by printing it to screen:

~~~
resolved_name
~~~
{: .language-r}

~~~
  search_string unique_name approximate_match ott_id is_synonym flags number_matches
1    amphibians    Amphibia              TRUE 544595      FALSE                    6
~~~
{: .output}

<br/>

The output of the function is a data frame table. In R (and other coding languages), objects are assigned to defined data structures called [**classes**](https://www.datamentor.io/r-programming/object-class-introduction/). This makes data manipulation of objects from different functions much easier.
A class is basically a data structure that is the same among all objects that belong to the same class.
To get the name of the class of the `tnrs_match_names()` output we can use the function `class`.

```{r, eval = TRUE}
class(resolved_name)
```

<br/>

As you can see, an object can belong to one or more classes.

Indeed, R is telling us that the output of `tnrs_match_names()` is a data frame (a type of table) and a **'match_names' object**, which is in turn a data frame with exactly `r ncol(resolved_name)` named columns: `search_string`, `unique_name`, `approximate_match`, `ott_id`, `is_synonym`, `flags`, and `number_matches`.
<!-- `r paste0("**", colnames(resolved_name)[-7], "**")`, and `r paste0("**", colnames(resolved_name)[7], "**")`. -->

Next we will explore the kinds of data that are stored in each of the columns of a 'match_names' object.

<br/>

### Kinds of data stored in a 'match_names' object

You should have a good idea by now of what type of data is stored in the `ott_ids` column.

Can you guess what type of data is displayed in the column `search_string` and `unique_name`?

How about `is_synonym`?

The column `approximate_match` tells us whether the unique name was inferred from the search string using approximate matching (TRUE) or not (FALSE).

<!-- The column `number_matches` tells us how many -->

Finally, the `flags` column tells us if our unique name has been flagged in the OTT
(TRUE) or not (FALSE). It also indicates the type of flag associated to the taxon. Flags are markers that indicate if the taxon in question is problematic and should be included in further analyses of the Open Tree workflow. You can read more about flags in the [Open Tree wiki](https://github.com/OpenTreeOfLife/reference-taxonomy/wiki/Taxon-flags).

<br/>

> ## Pro tip 1.1: Looking at "hidden" elements of a data object
>
> The 'match_names' object has more data that is not exposed on the screen and is not part of the main data structure. This "hidden" data is stored in the attributes of the object.
> All objects have at least one attribute, the class. Attributes can be accesed with the function `attributes()`, and are stored as a named list.
>
> > ## Explore the attributes of the 'match_names' object
> >
> > ```{r, eval = TRUE}
> > names(attributes(resolved_name))
> > ```
> >
> > Look at the attributes of other objects:
> > ```{r, eval = TRUE}
> > attributes(my_taxa)
> > ```
> >
> > As you can see there are many more attributes in a 'match_names' object than in simpler objects.
> {: .solution}
{: .testimonial}

<br/>

Now we know what kind of data is retrieved by the `tnrs_match_names()` function. Pretty cool!

### Getting OTT ids for multiple taxon names at a time

Now that we know about classes and the data structure of the `tnrs_match_names` output, we will learn how to use the tnrs_match_names function for multiple taxa.
In this case, you will have to create a character vector with your taxon names and use it as input for `tnrs_match_names`:

> ## Hands on! Running TNRS for multiple taxa
>
> Do a `tnrs_match_names()` run for the amphibians (Amphibia), the genus of the dog (_Canis_),
> the genus of the cat (_Felis_), the family of dolphins (Delphinidae), and the class
> of birds (Aves). Save the output to an object named `resolved_names`.
>
> Again, you can try different misspellings and synonyms of your taxa to see TNRS in action.
>
>
> ```{r, eval = TRUE}
> my_taxa <- c("amphibians", "canis", "felis", "delphinidae", "avess")
> resolved_names <- rotl::tnrs_match_names(names = my_taxa, do_approximate_matching = TRUE)
> ```
>
{: .challenge}

<br/>

### `r emo::ji("exclamation_mark")`  

If you do not get a match for all your taxa, and you get an unexpected warning message, it means that the `tnrs_match_names` function might not be working as expected. Please refer to Pro tip 1.2 below for alternative ways to get OTT ids for multiple taxa at a time using `tnrs_match_names`.

<br/>


> ## Pro Tip 1.2: Getting OTT ids for multiple taxa, the hacker way.
> 
> If you get a warning message saying that any of your taxon names "are not matched", it means that the `tnrs_match_names` function is not implementig TNRS for inputs with more than one name. This is an unexpected behaviour. See [this GitHub issue](https://github.com/ropensci/rotl/issues/134) for updates.
>
> As you already know, running `tnrs_match_names` using one name at a time, works as expected:
>
> ```{r, eval = TRUE, results = "hold"}
> resolved_amph <- rotl::tnrs_match_names(names = "amphibians", do_approximate_matching = TRUE)
> resolved_aves <- rotl::tnrs_match_names(names = "avess", do_approximate_matching = TRUE)
> ```
>
> If we want to run the function for a multiple element character vector, we can use a loop or an `sapply`, which will run the function individually for each taxa within `my_taxa`, avoiding the unexpected behaviours observed above.
>
>
> > ## Using `sapply`
> >
> > ```{r, eval = TRUE}
> > resolved_names <- sapply(my_taxa, rotl::tnrs_match_names)
> > class(resolved_names)
> > resolved_names
> > ```
> >
> > The data structure is not the same as we obtained using a single taxon name. To get that same data structure, we can transpose the output `resolved_names` with the function `t`, and make it a data.frame with the function `as.data.frame`:
> >
> > ```{r, eval = TRUE}
> > resolved_names <- t(resolved_names)
> > resolved_names <- as.data.frame(resolved_names)
> > class(resolved_names)
> > resolved_names
> > ```
> >
> {: .solution}
{: .testimonial}

<br/>

Finally,we are going to learn how to extract specific pieces of data from a `match_names` object to use in other functions and workflows.

<br/>

### Extracting data from a 'match_names' object

It is easy to access elements from a 'match_names' object using regular indexing.
For example, using the column number, we can extract all elements from a certain column.
Let's extract all data from the second column:

```{r, eval = TRUE}
resolved_name[,2]
```
We can also use the name of the column so we do not have to remember its position:
```{r, eval = TRUE}
resolved_name[,"unique_name"]
```
Because it is a 'data.frame', we can also access the values of any column by using
the "$" and the column name to index it, like this:

```{r, eval = TRUE}
resolved_name$unique_name
```

The 'match_names' object has a relatively simple structure that is easy to explore and mine.
We will see later that the outputs of other `rotl` functions are more complicated
and accessing their elements requires a lot of hacking. Fortunately, the `rotl` creators have
added some functions that allow interacting with these complicated outputs.
The functions `unique_name()`, `ott_id()`, and `flags()` extract values from the
respective columns of a 'match_names' object, in the form of a list instead of a vector.
To extract data from the other columns there are no specialized functions, so you will have to index.

<br/>

> ## Hands on!  Extract the OTT ids from a 'match_names' object
>
> You now have a 'match_names' object that we called `resolved_name`. There are at least two ways to extract the OTT ids from it. Can you figure them out? Store them in an object we will call `my_ott_ids`.
>
> **Hint**: You can find one solution by browsing the [rotl package documentation](https://cran.r-project.org/web/packages/rotl/rotl.pdf) to find a function that will do this for a 'match_names' object.
>
> You will find a second solution by using your knowledge on data frames and tables to extract the data from the `ott_id` column.
>
> > ## Look at some solutions
> >
> > Get the OTT ids as a list, with the function `ott_id()`:
> >
> > ```{r}
> > my_ott_id <- rotl::ott_id(resolved_name) # rotl:::ott_id.match_names(resolved_name) is the same.
> > my_ott_id
> > ```
> >
> > Or, get the OTT ids as a vector:
> >
> > ```{r}
> > my_ott_id <- resolved_name$ott_id # or resolved_name[, "ott_id"]
> > my_ott_id
> > ```
> >
<!-- > > Most of the functions we will explore later take an argument called _**ott_ids**_ in the form of a vector, not a list (?), so I usually prefer the second approach. -->
> {: .solution}
{: .challenge}

<br/>

There are no specialized functions to extract values from a row of a 'match_names' object, so we have to do some indexing.
You can get values from all columns of one row:

```{r, eval = TRUE}
resolved_name[1,]
```

Or get just one specific value from a certain column, using the column name:
```{r, eval = TRUE}
resolved_name[1,"unique_name"]
```
Or using the column position:
```{r, eval = TRUE}
resolved_name[1,2]
```
<br/>

> ## Hack: Name the rows of your 'match_names' object
>
> To facilitate the use of OTT ids later, you can name the rows of your 'match_names' object using the function `rownames()`.
>
> You can name them whatever you want. For example, you can use the `unique_name` identifier:
>
> ```{r, eval = FALSE}
> rownames(resolved_name) <- resolved_name$unique_name
> ```
>
> Or simply call them something short that makes sense to you and is easy to remember:
>
> ```{r}
> rownames(resolved_name) <- c("amphs", "dogs", "cats", "flippers", "birds")
> ```
>
> This will facilitate accessing elements of the 'match_names' object by allowing to just use the row name as row index (instead of a number).
>
> > ## There are at least two ways to do this.
> >
> > You can use the "$" to acces a named column of the data frame:
> > ```{r, eval = TRUE}
> > resolved_name["flippers",]$ott_id
> > ```
> > Or you can use the column name as column index:
> > ```{r, eval = TRUE}
> > resolved_name["flippers","ott_id"]
> > ```
> > In both cases, you will get the OTT id of the Delphinidae. Cool!
> {: .solution}
{: .challenge}



<br/>

> ## Pro tip 1.3: Extract data from the attributes of a 'match_names' object
>
> On Pro Tip 1.1, we saw that there is more data stored in the attributes of the 'match_names' object.
> The structure of this data is complicated and extracting it requires some hacking.
> There is one inbuilt function in the package `rotl` that will extract the synonyms from the attributes of a 'match_names' object.
>
> > ## The function `synonyms()`
> >
> > ```{r}
> > rotl::synonyms(resolved_name)
> > ```
> >
> > Neat!
> >
> {: .solution}
{: .testimonial}

<!--

### Taxonomic contexts and updating a 'match_names' object

Running a TNRS match can take some time, so if you just want to update a few elements from your 'match_names' object, you can use the functions `inspect()` and `update()`.

The _Mus_ example is fixed.

## **Hack!**

Put together two 'match_names' objects with `c()` or `rbind()`
{: .callout} -->

<br/>

> ## Note: Going from a common name to a scientific name
>
>  TNRS only deals with scientific names. If you want to work with common names, you will have to use a service that can get the scientific name of a list of common names. There are no functions in `rotl` to deal with this. We know of at least two places that have implemented this otherwise. The [OneZoom](https://github.com/OneZoom/OZtree) project has developed a service that provides all scientific names associated to common names in the Encyclopedia of Life databse.
The phylotastic project has implemented a [common name to scientific name service](https://github.com/phylotastic/phylo_services_docs/tree/master/ServiceDescription#common-name-to-scientific-name) that is also available in the r package [rphylotastic](https://github.com/phylotastic/rphylotastic).
{: .discussion}

<br/>

There we go! Now we know how to get OTT ids from a bunch of taxa of interest. Let's see what we can do with these on the next section.

<br/>

{% include links.md %}
