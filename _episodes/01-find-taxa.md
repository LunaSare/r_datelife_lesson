---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-find-taxa.md in _episodes_rmd/
source: Rmd
title: "1. Finding your taxa in the Open Tree of Life Taxonomy"
teaching: 5
exercises: 5
questions:
- "What is the Open Tree Taxonomy?"
- "What are OTT ids?"
- 'What does TNRS stand for?'
objectives:
- "Getting OTT ids for some taxa."
- "Understanding TNRS approximate matching and its sensitivity."
# - "Finding the utility of taxonomic contexts"
# - 'Discovering functions to handle a "match_names" object.'
keypoints:
- "OTT ids are the Open Tree of Life Taxonomy handlers, they allow us to interact with the Open Tree synthetic tree."
# - "taxonomic context is very important to find the correct _ott ids_ for our taxa."
- "You can go from a scientific name to an OTT id with TNRS matching."
- "You cannot go from a common name to OTT id with the Open Tree of Life tools."
---

<br/>
<br/>

<!-- ### The Open Tree Taxonomy and its identifiers -->

The [Open Tree Taxonomy](https://tree.opentreeoflife.org/about/taxonomy-version/ott3.2) (or **OTT**) synthesizes taxonomic information and assigns each taxon a unique identifier, which we know as the **OTT id**.

To deal with synonyms and scientific name misspellings, the Open Tree Taxonomy uses
the [Taxonomic Name Resolution Service](http://tnrs.iplantcollaborative.org/) (**TNRS**
from now on), that allows linking scientific names to a unique OTT id when necessary.

To interact with the OTT, we will learn how to use a number of function from the `rotl` package.
Go to setup if you need to check if you have `rotl` installed or if you need to install it.

To get OTT ids for a set of taxa we will use the `rotl` function `tnrs_match_names()`.

This function will get you a **match_names object**, which is a data frame with a certain number of columns. Let's generate a match_names object and check it out.



~~~
my_taxa <- c("amphibians", "canis", "felis", "delphinidae", "spheniscidae")
resolved_names <- rotl::tnrs_match_names(my_taxa)
class(resolved_names)
~~~
{: .language-r}



~~~
[1] "match_names" "data.frame" 
~~~
{: .output}



~~~
resolved_names
~~~
{: .language-r}



~~~
  search_string  unique_name approximate_match ott_id is_synonym flags
1    amphibians     Amphibia              TRUE 544595      FALSE      
2         canis        Canis             FALSE 372706      FALSE      
3         felis        Felis             FALSE 563165      FALSE      
4   delphinidae  Delphinidae             FALSE 698406      FALSE      
5  spheniscidae Spheniscidae             FALSE 494367      FALSE      
  number_matches
1              6
2              2
3              1
4              1
5              1
~~~
{: .output}
<br/>
<br/>

> ## **Challenge!** Get the OTT ids from a match_names object
>
> You now have a match_names object that we called resolved_names. There are two main ways to extract the OTT ids from it. Can you figure them out?
>
> > ## Solution
> >
> > As a list, with the function `ott_id()`:
> >
> > 
> > ~~~
> > rotl::ott_id(resolved_names)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > $Amphibia
> > [1] 544595
> > 
> > $Canis
> > [1] 372706
> > 
> > $Felis
> > [1] 563165
> > 
> > $Delphinidae
> > [1] 698406
> > 
> > $Spheniscidae
> > [1] 494367
> > 
> > attr(,"class")
> > [1] "otl_ott_id" "list"      
> > ~~~
> > {: .output}
> >
> > Or, as a vector:
> >
> > 
> > ~~~
> > resolved_names$ott_id
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] 544595 372706 563165 698406 494367
> > ~~~
> > {: .output}
> >
> > Most of the functions we will explore here take an argument called _ott ids_ as a numeric vector, so I will usually prefer the second approach.
> {: .solution}
{: .challenge}

<br/>
<br/>

> ## **Hack!**
>
> To facilitate the use of OTT ids later, you can name the rows of your match_names object.
>
> 
> ~~~
> rownames(resolved_names) <- resolved_names$unique_name
> ~~~
> {: .language-r}
>
> This will allow an easy access to elements of the match_names object by calling the taxon name.
>
> 
> ~~~
> resolved_names["Amphibia",]$ott_id
> ~~~
> {: .language-r}
> 
> [1] 544595
> 
> 
> ~~~
> # or
> resolved_names["Amphibia","ott_id"]
> ~~~
> {: .language-r}
> 
> [1] 544595
{: .callout}

<br/>
<br/>

> ## **Extra!** Accessing other elements of a match_names object
>
> Most elements of a match_names object can only be accessed as a vector, using the "$" symbol.
>
> The only other element that can be accessed as a list are **flags**.
>
> 
> ~~~
> rotl::flags(resolved_names)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> $Amphibia
> NULL
> 
> $Canis
> NULL
> 
> $Felis
> NULL
> 
> $Delphinidae
> NULL
> 
> $Spheniscidae
> NULL
> 
> attr(,"class")
> [1] "otl_flags" "list"     
> ~~~
> {: .output}
{: .testimonial}

<!-- ## **Challenge!** What do other elements of a "match_names" object tell us?

## Solution
{: .solution}
{: .challenge}


### Taxonomic contexts and updating a match_names object

Running a tnrs match can take some time, so if you just want to update a few elements from your match_names object, you can use the functions `inspect()` and `update()`.

The _Mus_ example is fixed.

## **Hack!**

Put together two "match_names" objects with `c()` or `rbind()`
{: .callout} -->
<br/>
<br/>

> ## **Extra!**
>
> Going from common name to scientific name can be achieved with other tools. Check out [phylotastic](https://phylo.cs.nmsu.edu/) or [OneZoom](https://github.com/OneZoom/OZtree) APIs for that.
{: .testimonial}

<br/>
<br/>

{% include links.md %}
